[{"content":"概览 技术栈：C++ + EasyX\n项目目标：设计游戏的动画框架，接入键盘的按键操作，提供更具交互性的玩法。在数据和逻辑层面，实现简单的2D平面内的碰撞检查；实现敌人的随机生成和索敌跟踪逻辑。添加音乐和音效，丰富游戏的完成度。添加主菜单界面。使用享元模式来优化程序性能。\n课程来源：B站-VoidMatrix\n核心玩法 玩家点击 开始 按钮进入游戏，使用 上 下 左 右 按键控制角色移动。在玩家角色的周围会有一圈子弹，野猪敌人会从屏幕外源源不断地涌向玩家。当子弹碰到敌人后，会击杀敌人并增加游戏得分。当敌人碰触到玩家角色时，游戏结束。\n项目主体开发 设计思路 游戏主框架的设计 创建窗口、创建游戏主循环和稳定帧率，这个写法基本是游戏开发框架的固定格式，因为在 系列笔记第0集 基础 中有详细的解释，此处就不再赘述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int main() { //========= 初始化数据 ========== initgraph(1280, 720); bool is_running = true; const int FPS = 60; ExMessage msg; BeginBatchDraw(); while (is_running)\t// 游戏主循环 { DWORD start_time = GetTickCount(); //========= 处理输入 ========= while (peekmessage(\u0026amp;msg)) { }\t//======== 处理更新 ========= cleardevice(); //======== 处理渲染 ========= FlushBatchDraw(); //========= 稳定帧率 ========= DWORD end_time = GetTickCount(); DWORD delta_time = end_time - start_time; if (delta_time \u0026lt; 1000 / FPS) { Sleep(1000 / FPS - delta_time); } } EndBatchDraw(); return 0; } 各个对象/类的设计 本项目并没有使用多态来抽象出更上层的对象。基本按照一个对象设计一个类的思路进行。为了更加符合初学者的直觉和理解，将所有的代码放在了main.cpp 中，使用了大量的全局变量实现项目。\n玩家类 子弹类（玩家周围的一圈子弹） 敌人类 动画类和图集类（实现和优化动画效果） 按钮基类 开始游戏按钮 退出游戏按钮 开发流程 游戏框架的设计\n图片的加载和渲染\n解决思路：使用EasyX的库函数：loadimage, putimage 问题：png图片会产生黑边 解决思路：自己在putimage的基础上重载一个含有透明通道的函数 注意：要包含对应的库 pragma comment(lib, \u0026quot;MSIMG32.LIB\u0026quot;) 动画的实现\n问题1：如何让图片动起来？ 解决思路：计数器 ===\u0026gt; 优化：计时器 问题2：动画的实现出现大量重复代码 解决思路：封装Animation类 角色移动的实现\n问题1：玩家移动时出现“卡顿感” 解决思路：使用bool变量来标识按键的按下和抬起，间接控制玩家的运动 问题2：玩家在斜线运动的速度快于水平/竖直方向 解决思路：使用单位向量统一各个方向的速度 问题：在试图实现敌人动画时发现和玩家的数据会一起混在Animation类中\n解决思路：使用面向对象的思想，创建各类管理各自的数据和逻辑 Player类的实现\nBullet类的实现\nEnemy类的实现\n问题1：敌人刷新机制的实现 解决思路：将敌人随机生成在地图外的一条边上 注意点：函数中如果需要传入别的类的对象，要用引用传入，如果不会改变这个参数，就加上const 问题2：敌人自动寻路机制的实现 解决思路：玩家位置与敌人位置之差，计算其单位向量，就是敌人的移动方向 2D碰撞检测的实现\n问题1：敌人和子弹的碰撞 解决思路：将敌人看作一个矩形处理，而子弹则按照点来处理 问题2：玩家和敌人的碰撞 解决思路：将敌人的中心点作为碰撞点，与玩家的矩形进行碰撞检测 子弹的更新、视觉效果的提升\n问题：让子弹的运动更加炫酷 解决思路：给子弹一个切向速度、一个径向速度 删除被击杀的敌人\n解决思路：先用 swap 将待删除的敌人移到vector末尾，再使用 pop_back，最后使用 delete 释放内存。这是一种 在元素次序无关 时性能较好的删除方法。 添加和绘制玩家得分\n添加音效\n解决思路：使用Windows的库函数：mciSendString 注意：要包含对应的库 pragma comment(lib, \u0026quot;Winmm.lib\u0026quot;) 优化：性能提升\n解决思路：使用 享元模式 优化资源加载 注意：不能再Animation中释放其持有的Atlas，因为它是共享的，所以只能由更上层的代码控制 添加主菜单UI、按钮类的设计\n关键步骤和解决思路 图片的加载和渲染 实现读取/加载图片 阅读文档，可以看到EasyX使用 loadimage 这个函数来加载图片，这个函数有一个重载，此处我们直接使用较简单的 从图片文件中获取图像 这一个：\n1 2 3 4 5 6 7 8 // 从图片文件获取图像(bmp/gif/jpg/png/tif/emf/wmf/ico) int loadimage( IMAGE* pDstImg,\t// 保存图像的 IMAGE 对象指针 LPCTSTR pImgFile,\t// 图片文件名 int nWidth = 0,\t// 图片的拉伸宽度 int nHeight = 0,\t// 图片的拉伸高度 bool bResize = false\t// 是否调整 IMAGE 的大小以适应图片 ); 此处需要注意的是，第一个参数是一个图片的指针对象。我们不直接将图片加载到窗口中，而是先保存到变量里，然后在后续绘制中使用，所以要传入要给非空指针；第二个参数是图片的路径字符串；后三个参数均提供了默认值，用来设置图片的缩放属性，此项目中用不到，所以暂时忽略。那么，要加载程序目录下的图片 text.jpg , 可以这样表示：\n1 2 IMAGE img; loadimage(\u0026amp;img, _T(\u0026#34;test.jpg\u0026#34;)); 实现渲染图片 同样阅读文档，我们发现可以使用 putimage 这个函数来绘制图片：\n1 2 3 4 5 6 7 // 绘制图像 void putimage( int dstX,\t// 绘制位置的 x 坐标 int dstY,\t// 绘制位置的 y 坐标 IMAGE *pSrcImg,\t// 要绘制的 IMAGE 对象指针 DWORD dwRop = SRCCOPY\t// 三元光栅操作码 ); 其中，第一二个参数是图片绘制在世界坐标中的位置。最后一个参数 三元光栅操作码 我们在这个项目中也忽略不计。那么如果要绘制刚刚加载的图片，这样我们可以写：\n1 2 3 4 5 6 // 加载图片 IMAGE img; loadimage(\u0026amp;img, _T(\u0026#34;test.jpg\u0026#34;)); // 绘制图片 putimage(100, 200, \u0026amp;img); 如果这张图片的像素是 300 * 300 ，那么这张图片在游戏界面中的坐标是这样的：\n需要注意的是，我们需要自己封装带有透明通道的 putimage函数，来解决显示的 png 图片带有黑框的问题：\n1 2 3 4 5 6 7 8 9 #pragma comment(lib, \u0026#34;MSIMG32.LIB\u0026#34;) void putimage_alpha(int x, int y, IMAGE* img) { int w = img-\u0026gt;getwidth(); int h = img-\u0026gt;getheight(); AlphaBlend(GetImageHDC(NULL), x, y, w, h, GetImageHDC(img), 0, 0, w, h, { AC_SRC_OVER,0,255,AC_SRC_ALPHA }); } 在函数之前（最好放在文件的开始处，要链接相关的库 #pragma comment(lib, \u0026quot;MSIMG32.LIB\u0026quot;) 。\n实现动画及渲染 如何让画面动起来？ 游戏中角色动画的常见实现可以笼统地分为两类：序列帧动画 和 关键帧动画 。\n序列帧动画 ：通常由一组图片素材构成，在程序中随着时间推移，我们不断地切换显示这一序列的图片，借助视觉暂留效应，产生动画效果。\n关键帧动画 如骨骼动画等，因为涉及更复杂的图形学技术，此处暂不讨论。\n注意，我们不能通过调用 Sleep() 函数来解决这个问题。因为当调用 Sleep() 函数时，程序会卡在那里，等待一定时间，这是一个“阻塞式”的行为，而在我们的游戏框架设计中，所有的画面渲染等操作，都应该式在一次又一次的循环中进行，每次循环的时间都控制在 1/60秒（FPS） 内。也就是说，我们切换动画轮播的任务，应该分摊在多帧之间进行，而不是在一次循环内全部结束。此处涉及到一个游戏编程中的核心思想：主循环内应尽量避免阻塞式的行为或者过于繁重且耗时过长的任务。\n为了确保动画序列帧可以在间隔固定的时间进行切换，采用了计时器的思路来做这样的一个计数器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int idx_current_anim = 0;\t// 1. 存储当前动画帧的帧索引 const int PLAYER_ANIM_NUM = 6;\t// 动画帧总数量 int main() { ..... while (is_running) { while (peekmessage(\u0026amp;msg)) { } static int counter = 0;\t// 2. 记录当前动画帧一共播放了几个游戏帧 // 用static修饰可以确保计数器只有在第一个游戏帧时被初始化为0 // 每5个游戏帧切换一个动画帧 if (++counter % 5 == 0) idx_current_anim++; if（idx_current_anim % PLAYER_ANIM_NUM == 0) idx_current_anim = 0; } ...... } 动画的渲染本质就是将IMAGE数组中的图片依次绘制即可。先加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int PLAYER_ANIM_NUM = 6;\t// 动画帧总数量 IMAGE img_player_left[PLAYER_ANIM_NUM]; IMAGE img_player_right[PLAYER_ANIM_NUM]; void load_animation() { for (size_t i = 0; i \u0026lt; PLAYER_ANIM_NUM; i++) { std::wstring path = L\u0026#34;img/player_left_\u0026#34; + std::to_wstring(i) + L\u0026#34;.png\u0026#34;; loadimage(\u0026amp;img_player_left[i], path.c_str()); } for (size_t i = 0; i \u0026lt; PLAYER_ANIM_NUM; i++) { std::wstring path = L\u0026#34;img/player_right_\u0026#34; + std::to_wstring(i) + L\u0026#34;.png\u0026#34;; loadimage(\u0026amp;img_player_right[i], path.c_str()); } } 然后在 main 中绘制这一系列动画图片的数组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main() { ...... while (is_running)\t// 游戏主循环 { DWORD start_time = GetTickCount(); //========= 处理输入 ========= while (peekmessage(\u0026amp;msg)) { }\t//======== 处理更新 ========= cleardevice(); //======== 处理渲染 ========= putimage_alpha(500, 500, \u0026amp;img_player_left[idx_current_anim]); FlushBatchDraw(); ...... } } 将动画的实现封装成动画类 数据结构层面，用vector来存储动画所需图片的指针vector\u0026lt;IMAGE*\u0026gt; 。在构造函数中，需要加载动画所需的图片资源同时为其分配了内存空间，那么对应的，需要在析构函数中释放图片资源被释放内存空间.\n在播放动画时，参数中除了需要知道动画播放的位置外，还增加了一个参数int delta用来表示距离上一次调用Play函数过去了多久时间，这是将“计数器”概念转为了“计时器”。之所以优化为这种设计，是因为一个动画的播放速度也就是 帧间隔，应该是与实际时间有关的，而不是与游戏的帧率有关，我们希望的是无论游戏帧的频率有多快，动画的播放速度是一致的，而不是画面刷新越快，动画播放越快。所以使用与实际时间有关的定时器，会比每一下调用都累加一次的计数器更能满足这种需求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Animation { public: Animation(LPCTSTR path, int num, int interval)\t// 加载动画帧图片资源 { interval_ms = interval; TCHAR path_file[256]; for (size_t i = 0; i \u0026lt; num; i++) { _sprintf_s(path_file, path, i); IMAGE* frame = new IMAGE(); loadimage(frame, path_file); frame_list.push_bacl(frame); } } void Play(int x, int y, int delta)\t// 播放动画 { timer += delta; if (timer \u0026gt;= interval_ms) { idx_frame = (idx_frame + 1) % frame_list.size(); timer =0; } // 绘制每一帧图片 pitimage_alpha(x, y, frame_list[idx_frame]); } ~Animation()\t// 释放资源 { for (size_t i = 0; i \u0026lt; frame_list.size(); i++) { delete frame_list[i]; } } private: vector\u0026lt;IMAGE*\u0026gt; frame_list; int interval_ms = 0;\t// 帧间隔 } 实现角色移动 如果我们直接在按下按键时，用在不同坐标轴上累加位移的方式来控制玩家，会出现手感上的“卡顿感”。这是因为 WM_KEYDOWN 消息的产生是与我们的主循环 异步进行 的，且触发的频率与操作系统和硬件设备相关，这就导致在有些游戏帧中事件处理部分对多个WM_KEYDOWN消息进行了处理，而在其余游戏帧中WM_KEYDOWN消息较少或没有，这就导致角色在某些游戏帧中前进的距离较远/近一些，在宏观上展现为移动过程中的卡顿感。另外，当我们按下方向键时，会首先有一个 WM_KEYDOWN 消息进入消息事件队列中，随后，当我们保持按键按下状态一段时间后，才会有接连不断的 WM_KEYDOWN 消息被触发。\n所以，要确保角色在每一个游戏帧中都连贯地移动相同的距离，从玩家的角色触发，就是：当玩家按下按键时，WM_KEYDOWN 消息触发，角色开始移动；当玩家抬起按键时，WM_KEYUP 消息触发，角色结束移动。所以使用相应的四个布尔变量来代表玩家的移动方向，我们通过改变按键的按下和抬起来改变这四个布尔变量的值，然后根据布尔变量的值来实现玩家在坐标轴上的位移：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void ProcessEvent(const ExMessage\u0026amp; msg) { if (msg.message == WM_KEYDOWN) { switch (msg.vkcode) { case VK_UP: is_moving_up = true; break; case VK_DOWN: is_moving_down = true; break; case VK_LEFT: is_moving_left = true; break; case VK_RIGHT: is_moving_right = true; break; } } if (msg.message == WM_KEYUP) { switch (msg.vkcode) { case VK_UP: is_moving_up = false; break; case VK_DOWN: is_moving_down = false; break; case VK_LEFT: is_moving_left = false; break; case VK_RIGHT: is_moving_right = false; break; } }\t} void Move() { if (is_moving_up) position.y -= SPEED; if (is_moving_down) position.y += SPEED; if (is_moving_left) position.x -= SPEED; if (is_moving_right) position.x += SPEED; } 另外，为了避免玩家在斜角运动时位移更多的问题，需要使其在该速度方向的向量是单位向量：\n1 2 3 4 5 6 7 8 9 10 int dir_x = is_move_right - is_move_left; int dir_y = is_move_down - is_move_up; double len_dir = sqrt(die_x * die_x + dir_y + dir_y); if(len_dir != 0) { double nomalized_x = dir_x / len_dir; double nomalized_y = dir_y / len_dir; player_pos.x += (int)(PLAYER_SPEED * normalized_x); player_pos.y += (int)(PLAYER_SPEED * normalized_y); } 各个类的封装 为了避免各个数据糅杂散落在项目的各处，将每个对象相关的逻辑和数据封装到各组的类中。以玩家类为例，大致的类的设计：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Player { public: Player() { // 初始化资源：动画资源、图片资源等 } ~Player() { // 释放资源 } void ProcessEvent(const ExMessage\u0026amp; msg) { // 玩家的输入逻辑 } void Move() { // 处理玩家移动 } void Draw(int delta) { // 绘制玩家 } private: ...... } 敌人类的实现细节 敌人的随机生成机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 敌人生成的边界 enum class SpawnEdge { Up = 0, Down, Left, Right }; // 将敌人生成在四条边界中随机的一条上 SpawnEdge edge = (SpawnEdge)(rand() % 4); // 具体的随机坐标值 switch (edge) { case SpawnEdge::Up: position.x = rand() % WINDOW_WIDTH; position.y = -FRAME_HEIGHT; break; case SpawnEdge::Down: position.x = rand() % WINDOW_WIDTH; position.y = WINDOW_HEIGHT; break; case SpawnEdge::Left: position.x = -FRAME_WIDTH; position.y = rand() % WINDOW_HEIGHT; break; case SpawnEdge::Right: position.x = WINDOW_WIDTH; position.y = rand () % WINDOW_HEIGHT; break; default: break; } 敌人的寻路机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void Move(const Player\u0026amp; player) { const POINT\u0026amp; player_position = player.GetPosition(); int dir_x = player_position.x - position.x; int dir_y = player_position.y - position.y; double dir_len = sqrt(dir_x * dir_x + dir_y * dir_y); if (dir_len != 0) { double normalized_x = dir_x / dir_len; double normalized_y = dir_y / dir_len; position.x += (int)(normalized_x * SPEED); position.y += (int)(normalized_y * SPEED); } if (dir_x \u0026gt; 0) facing_left = false; else if (dir_x \u0026lt; 0) facing_left = true; } 2D碰撞检测的实现 这部分都放在敌人类中实现，玩家或者子弹的对象作为引用传入函数中，避免不必要的拷贝。\n敌人和子弹 1 2 3 4 5 6 7 8 bool CheckBulletCollision(const Bullet\u0026amp; bullet) // 在参数前添加const：这个参数在函数中不会被修改 { // 将子弹等效为一个点，判断该点是否在敌人的矩形内 bool is_overlap_x = bullet.position.x \u0026gt;= position.x \u0026amp;\u0026amp; bullet.position.x \u0026lt;= position.x + FRAME_WIDTH; bool is_overlap_y = bullet.position.y \u0026gt;= position.y \u0026amp;\u0026amp; bullet.position.y \u0026lt;= position.y + FRAME_HEIGHT; return is_overlap_x \u0026amp;\u0026amp; is_overlap_y; } 敌人和玩家 在游戏的碰撞检测中，一般不会太严格。如果将敌人和玩家均作为一个矩形去检测碰撞，可能会发生两者只有一个角落重叠但是从视觉上看并未发生碰撞的情况，让玩家困惑。所以一般情况下，受击碰撞器都会小于图片尺寸。此处采用将敌人中心作为一个碰撞点来处理。\n1 2 3 4 5 6 7 8 9 bool CheckPlayerCollision(const Player\u0026amp; player) { // 将敌人的中心点位置视为敌人的碰撞点 POINT check_position = { position.x + FRAME_WIDTH / 2, position.y + FRAME_HEIGHT / 2 }; bool is_overlap_x = check_position.x \u0026gt;= player.GetPosition().x \u0026amp;\u0026amp; check_position.x \u0026lt;= player.GetPosition().x + player.FRAME_WIDTH; bool is_overlap_y = check_position.y \u0026gt;= player.GetPosition().y \u0026amp;\u0026amp; check_position.y \u0026lt;= player.GetPosition().y + player.FRAME_HEIGHT; return is_overlap_x \u0026amp;\u0026amp; is_overlap_y; } 子弹的更新和视觉效果的提升 因为围绕玩家的子弹是由一圈3颗子弹组成的，所以将其作为全局函数处理。\n关于子弹的运动，可以通过随着时间的推移改变α的值来表示，为了计算方便，此处的角度单位均为弧度：\n相应的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 更新子弹位置 void UpdateBullets(vector\u0026lt;Bullet\u0026gt;\u0026amp; bullet_list, const Player\u0026amp; player) { // 让子弹有一个不断收缩的效果，视觉上更加炫酷 const double RADIAL_SPEED = 0.0045; // 径向波动速度 const double TANGENT_SPEED = 0.0055; // 切向波动速度 double radian_interval = 2 * PI / bullet_list.size(); // 三颗子弹间的弧度间隔 // 根据玩家的位置，依次更新每颗子弹的位置 POINT player_position = player.GetPosition(); double radius = BULLET_BASE_RADIUS + BULLET_RADIUS_CHANGE_RANGE * sin(GetTickCount() * RADIAL_SPEED); for (size_t i = 0; i \u0026lt; bullet_list.size(); i++) { double radian = GetTickCount() * TANGENT_SPEED + radian_interval * i; bullet_list[i].position.x = player_position.x + player.FRAME_WIDTH / 2 + (int)(radius * sin(radian)); bullet_list[i].position.y = player_position.y + player.FRAME_HEIGHT / 2 + (int)(radius * cos(radian)); } } 删除被击杀的敌人 1 2 3 4 5 6 7 8 9 10 11 12 13 // 依次检查敌人列表，移除被击杀的敌人 for (size_t i = 0; i \u0026lt; enemy_list.size(); i++) // 因为此处会动容器本身，所以不能用迭代器遍历 { Enemy* enemy = enemy_list[i]; if (!enemy-\u0026gt;CheckAlive()) { // 和容器最后一个元素交换后，移除最后一个 // * 是元素顺序无关紧要时，性能较好的一种删除方法 swap(enemy_list[i], enemy_list.back()); enemy_list.pop_back(); delete enemy; } } 播放音效 此项目使用Windows的库函数实现播放音效。可以写成这样的代码：\n1 2 3 4 5 // 打开项目文件夹mus下的bgm.mp3文件，并且以后就叫它“bgm” mciSendString(_T(\u0026#34;open mus/bgm.mp3 alias bgm\u0026#34;), NULL, 0, NULL);\t// 加载音效 // 播放别名叫bgm的音效，并从开头处循环播放 mciSendString(_T(\u0026#34;play bgm repeat from 0\u0026#34;), NULL, 0, NULL);\t// 如果不需要循环，就不要加repeat\t提升性能：使用享元模式优化资源加载 游戏中的模型和贴图资源所占比例很高，对硬盘空间和游戏启动时间的消耗都很大。享元模式在游戏开发中非常常用。比如，游戏中的一棵树的资源，一般的写法和使用享元模式的写法对比：\n1 2 3 4 5 6 7 8 //========= 一般写法 ========= // 树的结构体 struct Tree { Model model;\t// 树的模型 Texture texture;// 树的贴图 int x, y, z;\t// 树的位置 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //======= 享元模式写法 ======= // 树的资产结构体 // 无论树有多少棵，均使用同一个TreeAsset对象中的数据 // 这也是绘制一棵树所需数据中最庞大的那部分 struct TreeAsset { Model model;\t// 树的模型 Texture texture;// 树的贴图 } // 树结构体 struct Tree { TreeAsset* asset;\t// 树的资产的指针 int x, y, z;\t// 树的位置 } 在此项目中，对Animation类进行重新拆分和设计，提取游戏中每一个个体敌人可以共享的数据 std::vector\u0026lt;IMAGE*\u0026gt; frame_list ，而其他三个私有成员，则是状态信息，是每一个敌人独有的。\n每个个体持有共享数据的图集类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 资源加载优化 class Atlas { public: Atlas(LPCTSTR path, int num) { // 加载图片 TCHAR path_file[256]; for (int i = 0; i \u0026lt; num; i++) { _stprintf_s(path_file, path, i); IMAGE* frame = new IMAGE(); loadimage(frame, path_file); frame_list.push_back(frame); } } ~Atlas() { for (int i = 0; i \u0026lt; frame_list.size(); i++) { delete frame_list[i]; } } public: vector\u0026lt;IMAGE*\u0026gt; frame_list; }; 每个个体独有的数据封装在Animation类中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Animation { public: Animation(Atlas* atlas, int interval) { anim_atlas = atlas; interval_ms = interval; } ~Animation() = default; // atlas是Animation类对象共享的公共资产，所以不能在Animation的析构函数中使用delete释放atlas指针 // 需要在更上一层释放（main） // 况且这里也没有new // 播放动画 void Play(int x, int y, int delta_time) { timer += delta_time; if (timer \u0026gt;= interval_ms) { idx_frame = (idx_frame + 1) % anim_atlas-\u0026gt;frame_list.size(); timer = 0; } putimage_alpha(x, y, anim_atlas-\u0026gt;frame_list[idx_frame]); } private: int interval_ms = 0; // 帧间隔 int timer = 0; // 动画计时器 int idx_frame = 0; // 动画帧索引 private: Atlas* anim_atlas; // 需要持有Atlas类的指针 }; 按钮类的设计 按钮的状态有三种：Idle、Hover和Pushed，理清这三者的跳转关系来编写玩家输入的代码：\n相应的，我们需要处理的情况也有三种：鼠标移动、左键按下、左键抬起\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void ProcessEvent(const ExMessage\u0026amp; msg) { switch (msg.message) { case WM_MOUSEMOVE: if (status == Status::Idle \u0026amp;\u0026amp; CheckCursorHit(msg.x, msg.y)) status = Status::Hovered; else if (status == Status::Idle \u0026amp;\u0026amp; !CheckCursorHit(msg.x, msg.y)) status = Status::Idle; else if (status == Status::Hovered \u0026amp;\u0026amp; !CheckCursorHit(msg.x, msg.y)) status = Status::Idle; break; case WM_LBUTTONDOWN: if (CheckCursorHit(msg.x, msg.y)) status = Status::Pushed; break; case WM_LBUTTONUP: if (status == Status::Pushed) OnClick(); break; default: break; } } 番外篇：角色动画特效和像素缓冲区 完整源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /* =============== 知识点 =============== * 1.主循环内应尽量避免阻塞式行为或者过于繁重且耗时过长的任务 * 2.用计数器和用计时器来控制动画的帧更新的区别： *\t计数器：会存在电脑的刷新速度越快，帧更新就越快的情况 *\t计时器：不管什么电脑，帧更新都和实际的时间流逝一致 * 3.利用享元模式对资源加载进行优化 */ const int WINDOW_WIDTH = 1280; const int WINDOW_HEIGHT = 720; const int FPS = 60; const double PI = 3.14159; const int BULLET_BASE_RADIUS = 100; const int BULLET_RADIUS_CHANGE_RANGE = 25; const int PLAYER_ANIM_NUM = 6; const int ENEMY_ANIM_NUM = 6; const int BUTTON_WIDTH = 192; const int BUTTON_HEIGHT = 75; bool is_game_started = false; bool is_running = true; #pragma comment(lib, \u0026#34;MSIMG32.LIB\u0026#34;) // pragma comment作用：链接库 #pragma comment(lib, \u0026#34;Winmm.lib\u0026#34;) // 音频播放的库 // 自己定义一个可以处理透明度的图片绘制函数 void putimage_alpha(int x, int y, IMAGE* img); // 资源加载优化 class Atlas { public: Atlas(LPCTSTR path, int num) { // 加载图片 TCHAR path_file[256]; for (int i = 0; i \u0026lt; num; i++) { _stprintf_s(path_file, path, i); IMAGE* frame = new IMAGE(); loadimage(frame, path_file); frame_list.push_back(frame); } } ~Atlas() { for (int i = 0; i \u0026lt; frame_list.size(); i++) { delete frame_list[i]; } } public: vector\u0026lt;IMAGE*\u0026gt; frame_list; }; Atlas* atlas_player_left; // 放在main中初始化 Atlas* atlas_player_right; Atlas* atlas_enemy_left; Atlas* atlas_enemy_right; class Animation { public: Animation(Atlas* atlas, int interval) { anim_atlas = atlas; interval_ms = interval; } ~Animation() = default; // atlas是Animation类对象共享的公共资产，所以不能在Animation的析构函数中使用delete释放atlas指针 // 需要在更上一层释放（main） // 况且这里也没有new // 播放动画 void Play(int x, int y, int delta_time) { timer += delta_time; if (timer \u0026gt;= interval_ms) { idx_frame = (idx_frame + 1) % anim_atlas-\u0026gt;frame_list.size(); timer = 0; } putimage_alpha(x, y, anim_atlas-\u0026gt;frame_list[idx_frame]); } private: int interval_ms = 0; // 帧间隔 int timer = 0; // 动画计时器 int idx_frame = 0; // 动画帧索引 private: Atlas* anim_atlas; // 需要持有Atlas类的指针 }; class Player { public: Player() { loadimage(\u0026amp;img_shadow, _T(\u0026#34;img/shadow_player.png\u0026#34;)); anim_left = new Animation(atlas_player_left, 45); anim_right = new Animation(atlas_player_right, 45); } ~Player() { delete anim_left; delete anim_right; } void ProcessEvent(const ExMessage\u0026amp; msg) { if (msg.message == WM_KEYDOWN) { switch (msg.vkcode) { case VK_UP: is_moving_up = true; break; case VK_DOWN: is_moving_down = true; break; case VK_LEFT: is_moving_left = true; break; case VK_RIGHT: is_moving_right = true; break; } } if (msg.message == WM_KEYUP) { switch (msg.vkcode) { case VK_UP: is_moving_up = false; break; case VK_DOWN: is_moving_down = false; break; case VK_LEFT: is_moving_left = false; break; case VK_RIGHT: is_moving_right = false; break; } }\t} void Move() { if (is_moving_up) position.y -= SPEED; if (is_moving_down) position.y += SPEED; if (is_moving_left) position.x -= SPEED; if (is_moving_right) position.x += SPEED; // 解决斜线移动速度更快的问题 int dir_x = is_moving_right - is_moving_left; // 向右为x轴正方向 int dir_y = is_moving_down - is_moving_up; // 向下为y轴正方向 double len_dir = sqrt(dir_x * dir_x + dir_y * dir_y); if (len_dir != 0) { double normalized_x = dir_x / len_dir; double normalized_y = dir_y / len_dir; position.x += (int)(SPEED * normalized_x); position.y += (int)(SPEED * normalized_y); } // 限制玩家移动范围 if (position.x \u0026lt; 0) position.x = 0; if (position.y \u0026lt; 0) position.y = 0; if (position.x + FRAME_WIDTH \u0026gt; WINDOW_WIDTH) position.x = WINDOW_WIDTH - FRAME_WIDTH; if (position.y + FRAME_HEIGHT \u0026gt; WINDOW_HEIGHT) position.y = WINDOW_HEIGHT - FRAME_HEIGHT; } void Draw(int delta_time) { // 在绘制玩家之前绘制阴影 int shadow_pos_x = position.x + (FRAME_WIDTH / 2 - SHADOW_WIDTH / 2); int shadow_pos_y = position.y + FRAME_HEIGHT - 8; putimage_alpha(shadow_pos_x, shadow_pos_y, \u0026amp;img_shadow); static bool facing_left = false; int dir_x = is_moving_right - is_moving_left; if (dir_x \u0026lt; 0) facing_left = true; else if (dir_x \u0026gt; 0) facing_left = false; if (facing_left) anim_left-\u0026gt;Play(position.x, position.y, delta_time); else anim_right-\u0026gt;Play(position.x, position.y, delta_time); } const POINT\u0026amp; GetPosition() const { return position; } public: const int FRAME_WIDTH = 80; const int FRAME_HEIGHT = 80; private: const int SPEED = 3; // player移动的速度 const int SHADOW_WIDTH = 32;\tprivate:\tIMAGE img_shadow; // 玩家脚下阴影 Animation* anim_left; Animation* anim_right; POINT position = { 500, 500 }; // 玩家坐标 // 解决消息处理和按键异步造成的玩家移动卡顿问题 bool is_moving_up = false; bool is_moving_down = false; bool is_moving_left = false; bool is_moving_right = false; }; class Bullet { public: Bullet() = default; ~Bullet() = default; void Draw() const // 在成员方法后面加上const：这个方法不会修改类的成员变量 { setlinecolor(RGB(255, 155, 50)); setfillcolor(RGB(200, 75, 10)); fillcircle(position.x, position.y, RADIUS); } public: POINT position = { 0, 0 }; private: const int RADIUS = 10; }; class Enemy { public: Enemy() { loadimage(\u0026amp;img_shadow, _T(\u0026#34;img/shadow_enemy.png\u0026#34;)); anim_left = new Animation(atlas_enemy_left, 45); anim_right = new Animation(atlas_enemy_right, 45); // 敌人生成的边界 enum class SpawnEdge { Up = 0, Down, Left, Right }; // 将敌人生成在四条边界中随机的一条上 SpawnEdge edge = (SpawnEdge)(rand() % 4); // 具体的随机坐标值 switch (edge) { case SpawnEdge::Up: position.x = rand() % WINDOW_WIDTH; position.y = -FRAME_HEIGHT; break; case SpawnEdge::Down: position.x = rand() % WINDOW_WIDTH; position.y = WINDOW_HEIGHT; break; case SpawnEdge::Left: position.x = -FRAME_WIDTH; position.y = rand() % WINDOW_HEIGHT; break; case SpawnEdge::Right: position.x = WINDOW_WIDTH; position.y = rand () % WINDOW_HEIGHT; break; default: break; } } ~Enemy() { delete anim_left; delete anim_right; } bool CheckBulletCollision(const Bullet\u0026amp; bullet) // 在参数前添加const：这个参数在函数中不会被修改 { // 将子弹等效为一个点，判断该点是否在敌人的矩形内 bool is_overlap_x = bullet.position.x \u0026gt;= position.x \u0026amp;\u0026amp; bullet.position.x \u0026lt;= position.x + FRAME_WIDTH; bool is_overlap_y = bullet.position.y \u0026gt;= position.y \u0026amp;\u0026amp; bullet.position.y \u0026lt;= position.y + FRAME_HEIGHT; return is_overlap_x \u0026amp;\u0026amp; is_overlap_y; } bool CheckPlayerCollision(const Player\u0026amp; player) { // 将敌人的中心点位置视为敌人的碰撞点 POINT check_position = { position.x + FRAME_WIDTH / 2, position.y + FRAME_HEIGHT / 2 }; bool is_overlap_x = check_position.x \u0026gt;= player.GetPosition().x \u0026amp;\u0026amp; check_position.x \u0026lt;= player.GetPosition().x + player.FRAME_WIDTH; bool is_overlap_y = check_position.y \u0026gt;= player.GetPosition().y \u0026amp;\u0026amp; check_position.y \u0026lt;= player.GetPosition().y + player.FRAME_HEIGHT; return is_overlap_x \u0026amp;\u0026amp; is_overlap_y; } void Move(const Player\u0026amp; player) { const POINT\u0026amp; player_position = player.GetPosition(); int dir_x = player_position.x - position.x; int dir_y = player_position.y - position.y; double dir_len = sqrt(dir_x * dir_x + dir_y * dir_y); if (dir_len != 0) { double normalized_x = dir_x / dir_len; double normalized_y = dir_y / dir_len; position.x += (int)(normalized_x * SPEED); position.y += (int)(normalized_y * SPEED); } if (dir_x \u0026gt; 0) facing_left = false; else if (dir_x \u0026lt; 0) facing_left = true; } void Draw(int delta_time) { int shadow_pos_x = position.x + (FRAME_WIDTH / 2 - SHADOW_WIDTH / 2); int shadow_pos_y = position.y + FRAME_HEIGHT - 35; putimage_alpha(shadow_pos_x, shadow_pos_y, \u0026amp;img_shadow); if (facing_left) anim_left-\u0026gt;Play(position.x, position.y, delta_time); else anim_right-\u0026gt;Play(position.x, position.y, delta_time); } void Hurt() { alive = false; } bool CheckAlive() { return alive; } private: const int SPEED = 2; const int FRAME_WIDTH = 80; const int FRAME_HEIGHT = 80; const int SHADOW_WIDTH = 48;\tprivate: IMAGE img_shadow; Animation* anim_left; Animation* anim_right; POINT position = { 0, 0 }; bool facing_left = false; bool alive = true; }; // Button的基类 class Button { public: Button(RECT rect, LPCTSTR path_imag_idle, LPCTSTR path_imag_hovered, LPCTSTR path_imag_pushed) // 加载图片 { region = rect; loadimage(\u0026amp;img_idle, path_imag_idle); loadimage(\u0026amp;img_hovered, path_imag_hovered); loadimage(\u0026amp;img_pushed, path_imag_pushed); } ~Button() = default; void Draw() { switch (status) { case Status::Idle: putimage(region.left, region.top, \u0026amp;img_idle); break; case Status::Hovered: putimage(region.left, region.top, \u0026amp;img_hovered); break; case Status::Pushed: putimage(region.left, region.top, \u0026amp;img_pushed); break; } } void ProcessEvent(const ExMessage\u0026amp; msg) { switch (msg.message) { case WM_MOUSEMOVE: if (status == Status::Idle \u0026amp;\u0026amp; CheckCursorHit(msg.x, msg.y)) status = Status::Hovered; else if (status == Status::Idle \u0026amp;\u0026amp; !CheckCursorHit(msg.x, msg.y)) status = Status::Idle; else if (status == Status::Hovered \u0026amp;\u0026amp; !CheckCursorHit(msg.x, msg.y)) status = Status::Idle; break; case WM_LBUTTONDOWN: if (CheckCursorHit(msg.x, msg.y)) status = Status::Pushed; break; case WM_LBUTTONUP: if (status == Status::Pushed) OnClick(); break; default: break; } } protected: virtual void OnClick() = 0; private: bool CheckCursorHit(int x, int y) { return x \u0026gt;= region.left \u0026amp;\u0026amp; x \u0026lt;= region.right \u0026amp;\u0026amp; y \u0026gt;= region.top \u0026amp;\u0026amp; y \u0026lt;= region.bottom; } private: enum class Status { Idle = 0, Hovered, Pushed }; private: RECT region; IMAGE img_idle; IMAGE img_hovered; IMAGE img_pushed; Status status = Status::Idle; }; // 开始游戏按钮 class StartGameButton : public Button { public: StartGameButton(RECT rect, LPCTSTR path_imag_idle, LPCTSTR path_imag_hovered, LPCTSTR path_imag_pushed) : Button(rect, path_imag_idle, path_imag_hovered, path_imag_pushed) {} ~StartGameButton() = default; protected: void OnClick() { is_game_started = true; mciSendString(_T(\u0026#34;play bgm repeat from 0\u0026#34;), NULL, 0, NULL); // 重复播放bgm } }; // 退出游戏按钮 class QuitGameButton : public Button { public: QuitGameButton(RECT rect, LPCTSTR path_imag_idle, LPCTSTR path_imag_hovered, LPCTSTR path_imag_pushed) : Button(rect, path_imag_idle, path_imag_hovered, path_imag_pushed) {} ~QuitGameButton() = default; protected: void OnClick() { is_running = false; } }; void TryGenerateEnemy(vector\u0026lt;Enemy*\u0026gt;\u0026amp; enemy_list); void UpdateBullets(vector\u0026lt;Bullet\u0026gt;\u0026amp; bullet_list, const Player\u0026amp; player); void DrawPlayerScore(int score); int main() { initgraph(WINDOW_WIDTH, WINDOW_HEIGHT); mciSendString(_T(\u0026#34;open mus/bgm.mp3 alias bgm\u0026#34;), NULL, 0, NULL); // 加载 mciSendString(_T(\u0026#34;open mus/hit.wav alias hit\u0026#34;), NULL, 0, NULL); // player和enemy的构造函数都要用到atlas，所以atlas的初始化必须放在这两者之前 atlas_player_left = new Atlas(_T(\u0026#34;img/player_left_%d.png\u0026#34;), PLAYER_ANIM_NUM); atlas_player_right = new Atlas(_T(\u0026#34;img/player_right_%d.png\u0026#34;), PLAYER_ANIM_NUM); atlas_enemy_left = new Atlas(_T(\u0026#34;img/enemy_left_%d.png\u0026#34;), ENEMY_ANIM_NUM); atlas_enemy_right = new Atlas(_T(\u0026#34;img/enemy_right_%d.png\u0026#34;), ENEMY_ANIM_NUM); Player player; vector\u0026lt;Enemy*\u0026gt; enemy_list; vector\u0026lt;Bullet\u0026gt; bullet_list(3); // 子弹只有三颗，所以不使用指针的形式，避免内存泄漏的风险\tExMessage msg; IMAGE img_menu;\tIMAGE img_background;\tint score = 0; RECT region_btn_start_game, region_btn_quit_game; // ================ UI ================ region_btn_start_game.left = (WINDOW_WIDTH - BUTTON_WIDTH) / 2; region_btn_start_game.right = region_btn_start_game.left + BUTTON_WIDTH; region_btn_start_game.top = 430; region_btn_start_game.bottom = region_btn_start_game.top + BUTTON_HEIGHT; region_btn_quit_game.left = (WINDOW_WIDTH - BUTTON_WIDTH) / 2; region_btn_quit_game.right = region_btn_quit_game.left + BUTTON_WIDTH; region_btn_quit_game.top = 550; region_btn_quit_game.bottom = region_btn_quit_game.top + BUTTON_HEIGHT; StartGameButton btn_start_game = StartGameButton(region_btn_start_game, _T(\u0026#34;img/ui_start_idle.png\u0026#34;), _T(\u0026#34;img/ui_start_hovered.png\u0026#34;), _T(\u0026#34;img/ui_start_pushed.png\u0026#34;)); QuitGameButton btn_quit_game = QuitGameButton(region_btn_quit_game, _T(\u0026#34;img/ui_quit_idle.png\u0026#34;), _T(\u0026#34;img/ui_quit_hovered.png\u0026#34;), _T(\u0026#34;img/ui_quit_pushed.png\u0026#34;)); loadimage(\u0026amp;img_menu, _T(\u0026#34;img/menu.png\u0026#34;)); loadimage(\u0026amp;img_background, _T(\u0026#34;img/background.png\u0026#34;)); BeginBatchDraw(); while (is_running) { DWORD start_time = GetTickCount(); while (peekmessage(\u0026amp;msg)) { if (is_game_started) { player.ProcessEvent(msg); } else { btn_start_game.ProcessEvent(msg); btn_quit_game.ProcessEvent(msg); } }\tif (is_game_started) { player.Move(); UpdateBullets(bullet_list, player); TryGenerateEnemy(enemy_list); for (Enemy* enemy : enemy_list) enemy-\u0026gt;Move(player); // 检测敌人与玩家的碰撞 for (Enemy* enemy : enemy_list) { if (enemy-\u0026gt;CheckPlayerCollision(player)) { static TCHAR text[128]; _stprintf_s(text, _T(\u0026#34;最终得分：%d！\u0026#34;), score); MessageBox(GetHWnd(), text, _T(\u0026#34;游戏结束\u0026#34;), MB_OK); is_running = false; break; } } // 检测敌人与子弹的碰撞 for (Enemy* enemy : enemy_list) { for (const Bullet\u0026amp; bullet : bullet_list) { if (enemy-\u0026gt;CheckBulletCollision(bullet)) { mciSendString(_T(\u0026#34;play hit from 0\u0026#34;), NULL, 0, NULL); enemy-\u0026gt;Hurt(); score++; } } } // 依次检查敌人列表，移除被击杀的敌人 for (size_t i = 0; i \u0026lt; enemy_list.size(); i++) // 因为此处会动容器本身，所以不能用迭代器遍历 { Enemy* enemy = enemy_list[i]; if (!enemy-\u0026gt;CheckAlive()) { // 和容器最后一个元素交换后，移除最后一个 // * 是元素顺序无关紧要时，性能较好的一种删除方法 swap(enemy_list[i], enemy_list.back()); enemy_list.pop_back(); delete enemy; } } } cleardevice(); // ======= Draw ======= if (is_game_started) { putimage(0, 0, \u0026amp;img_background); player.Draw(1000 / FPS); for (Enemy* enemy : enemy_list) enemy-\u0026gt;Draw(1000 / FPS); for (Bullet\u0026amp; bullet : bullet_list) bullet.Draw(); DrawPlayerScore(score); } else { putimage(0, 0, \u0026amp;img_menu); btn_start_game.Draw(); btn_quit_game.Draw(); } FlushBatchDraw(); DWORD end_time = GetTickCount(); DWORD delta_time = end_time - start_time; if (delta_time \u0026lt; 1000 / FPS) { Sleep(1000 / FPS - delta_time); } } // atlas指针需在游戏主循环结束后释放 delete atlas_player_left; delete atlas_player_right; delete atlas_enemy_left; delete atlas_enemy_right; EndBatchDraw(); return 0; } void putimage_alpha(int x, int y, IMAGE* img) { int w = img-\u0026gt;getwidth(); int h = img-\u0026gt;getheight(); AlphaBlend(GetImageHDC(NULL), x, y, w, h, GetImageHDC(img), 0, 0, w, h, { AC_SRC_OVER,0,255,AC_SRC_ALPHA }); } void TryGenerateEnemy(vector\u0026lt;Enemy*\u0026gt;\u0026amp; enemy_list) { const int INTERVAL = 100; static int counter = 0; if (++counter % INTERVAL == 0) { enemy_list.push_back(new Enemy()); } } // 更新子弹位置 void UpdateBullets(vector\u0026lt;Bullet\u0026gt;\u0026amp; bullet_list, const Player\u0026amp; player) { // 让子弹有一个不断收缩的效果，视觉上更加炫酷 const double RADIAL_SPEED = 0.0045; // 径向波动速度 const double TANGENT_SPEED = 0.0055; // 切向波动速度 double radian_interval = 2 * PI / bullet_list.size(); // 三颗子弹间的弧度间隔 // 根据玩家的位置，依次更新每颗子弹的位置 POINT player_position = player.GetPosition(); double radius = BULLET_BASE_RADIUS + BULLET_RADIUS_CHANGE_RANGE * sin(GetTickCount() * RADIAL_SPEED); for (size_t i = 0; i \u0026lt; bullet_list.size(); i++) { double radian = GetTickCount() * TANGENT_SPEED + radian_interval * i; bullet_list[i].position.x = player_position.x + player.FRAME_WIDTH / 2 + (int)(radius * sin(radian)); bullet_list[i].position.y = player_position.y + player.FRAME_HEIGHT / 2 + (int)(radius * cos(radian)); } } void DrawPlayerScore(int score) { static TCHAR text[64]; _stprintf_s(text, _T(\u0026#34;当前玩家得分：%d\u0026#34;), score); setbkmode(TRANSPARENT); settextcolor(RGB(255, 85, 185)); outtextxy(10, 10, text); } 复盘和总结 ","date":"2025-10-08T10:47:30+02:00","image":"https://nullshowjl.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/teyvat0_hu_3201b32055f1271a.webp","permalink":"https://nullshowjl.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/","title":"【从零开始的C++游戏开发】提瓦特幸存者"},{"content":"术语 英文表达 中文解释 使用场景 / 备注 curly braces 花括号 {} 常用于代码块、函数体 greater than or equal to (\u0026gt;=) 大于等于 条件判断 polymorphism 多态 面向对象编程核心概念 inheritance 继承 类之间的关系 encapsulation 封装 数据隐藏与接口暴露 constructor / destructor 构造函数 / 析构函数 C++类生命周期管理 reference / pointer 引用 / 指针 C++变量访问方式 overload / override 重载 / 重写 函数或运算符扩展 compile-time / runtime 编译时 / 运行时 性能与错误定位相关 stack / heap 栈 / 堆 内存管理 thread-safe 线程安全 并发编程 undefined behavior 未定义行为 编译器无法保证结果 template / generic 模板 / 泛型 C++/TypeScript等通用编程 STL (Standard Template Library) 标准模板库 C++常用数据结构与算法 lambda expression 匿名函数表达式 函数式编程风格 scope / lifetime 作用域 / 生命周期 变量可见性与存活时间 行业表达 英文表达 中文解释 使用场景 / 备注 MVP (Minimum Viable Product) 最小可行产品 产品开发初期 pivot 战略转向 产品或业务方向调整 iteration 迭代 敏捷开发周期 sprint 冲刺周期 敏捷开发术语 backlog 待办事项列表 项目管理 playtest 游戏测试 游戏开发流程 asset pipeline 资源处理流程 游戏美术与技术协作 hitbox / collision detection 碰撞盒 / 碰撞检测 游戏物理逻辑 frame rate / FPS 帧率 游戏性能指标 latency / lag 延迟 / 卡顿 网络性能问题 live ops 运营活动 游戏上线后的持续运营 monetization 变现策略 游戏商业模式 sandbox environment 沙盒环境 安全测试或实验环境 scalability 可扩展性 系统设计目标 CI/CD (Continuous Integration / Deployment) 持续集成 / 部署 DevOps 流程 表达习惯 英文表达 中文解释 使用场景 / 备注 Let\u0026rsquo;s refactor this module. 我们来重构这个模块。 团队协作时建议优化代码结构 This function is too tightly coupled. 这个函数耦合度太高。 表达设计问题 Can we abstract this logic? 我们能抽象这段逻辑吗？ 提高复用性 This breaks the single responsibility principle. 这违反了单一职责原则。 代码设计讨论 Let\u0026rsquo;s keep it DRY (Don\u0026rsquo;t Repeat Yourself). 避免重复代码。 编程原则 This is a bit verbose. 这段代码有点啰嗦。 表达代码简洁性问题 It\u0026rsquo;s more idiomatic to use\u0026hellip; 更符合语言习惯的是用\u0026hellip; 语言风格建议 Let\u0026rsquo;s decouple the UI from the logic. 把 UI 和逻辑分离。 前端架构优化 This is a good candidate for a helper function. 可以提取为辅助函数。 提高可读性 We should avoid side effects here. 应避免副作用。 函数式编程建议 面试沟通 英文表达 中文解释 使用场景 / 备注 I led the implementation of\u0026hellip; 我主导了\u0026hellip;的实现 项目介绍 We optimized the performance by\u0026hellip; 我们通过\u0026hellip;优化了性能 技术成果展示 I collaborated with cross-functional teams. 我与跨职能团队合作 展现沟通能力 One challenge we faced was\u0026hellip; 我们遇到的一个挑战是\u0026hellip; 问题分析 I proposed a solution that\u0026hellip; 我提出了一个解决方案\u0026hellip; 展现主动性 The project was deployed to production in\u0026hellip; 项目已上线于\u0026hellip; 项目成果说明 I ensured code quality through\u0026hellip; 我通过\u0026hellip;保障了代码质量 展现工程规范意识 I’m comfortable working in agile environments. 我适应敏捷开发环境 团队协作能力 I’m currently exploring C++ for backend performance. 我正在研究 C++ 提升后端性能 展现学习动力 I’d love to contribute to scalable systems. 我希望参与可扩展系统的开发 职业目标表达 ","date":"2025-09-28T10:28:14+02:00","image":"https://nullshowjl.github.io/p/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%B8%B8%E7%94%A8%E8%A1%A8%E8%BE%BE/professional-english_hu_e8c5a0b5141c8420.webp","permalink":"https://nullshowjl.github.io/p/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%B8%B8%E7%94%A8%E8%A1%A8%E8%BE%BE/","title":"【专业英语】常用表达"},{"content":"概览 项目目标：从零开始开发一个个人博客网站，用来记录和分享我在学习、开发中的笔记 、历程和感悟，也是 portfolio 的一部分 技术栈：GitHub Page + Hugo，在Stack theme基础上进行轻量定制修改 开始时间：2025-09-14 当前状态：进行中 学习资源：Hugo官方文档、stack主题文档、B站及网上各位大佬的教程 仓库链接：GitHub 时间线——阶段一 2025-09-14 目标： 创建网站并完成自动部署 添加基础版 看板娘 遇到的问题： 中英语切换时找不到网页 icon小图标在网站标签不显示 解决方法： 在VS Code中使用Github copilot，帮我写了转换语言的js文件 用在别人网页中成功显示的小图标进行测试，排除了图片本身的问题；后来因为处理别的模块，没有在意icon小图标，一段时间后自动显示出来了 思考/收获： 需要边开发边系统学习web programming，才能“知其然，知其所以然”，而不是百分之百依赖AI Github Pages的部署很快，但是在网页显示没有那么及时；如果检查了仓库已经推送上去了，如果此时效果还未显示，不要着急，等一等 2025-09-16 目标： 左边侧栏添加 更新日志 上传第一篇博客（中文版） 修改字体 使用自定义鼠标 遇到的问题： 自定义鼠标不显示 解决方法： 查看了教程博客的评论区，发现可能是图片的问题。使用了教程博主的图片素材测试，发现确实如此 思考/收获： 遇到问题可以看文章或者视频的评论区，常有启发和收获，因为我遇到过的问题也许别人早就遇到并解决了 2025-09-18 目标：做完一系列基础美化\n遇到的问题：\n不知道如何能使每个语言、代码都显示对应的字体 自动部署时遇到 语法报错 失败 解决方法：\n使用Copilot生成代码建议解决了字体问题 语法报错是和缩进有关的，用VS Code它会自动按照它认为对的格式，但其实是错的。换成 记事本 解决 思考/收获：\n前端的语言和缩进也是有关系的，以后需要用 记事本 或者其他编辑器操作，尽量不用VS Code避免类似情况发生 2025-09-19 目标：\n继续做基础美化 调整 背景颜色 图标和文本 添加 动态背景 添加 文章浏览量 统计 遇到的问题：\n调整背景颜色时先遇到了两个图标同时显示的问题，解决后发现 文本格式 没有和左侧菜单栏的其他项目文本对齐 备注：\n尝试解决了很久没有成功，先放一放，等学一段时间前端后再回过头来尝试解决\n2025-09-20 目标：\n继续做基础美化 添加 主页加载动画 添加 网站底部动画 添加 博客发表热力图 遇到的问题：\n网站底部出现不是博客内容的文字 想为 头像 下的小图标增加动画效果，但是没有实现效果 解决方法：\n利用AI排查出是custom.html的注释问题，我想当然地使用了C++的注释，但是被浏览器当做文本处理 备注：\n小图标 的动画效果在学完一些前端后再尝试解决（9-23已解决） 思考/收获：\n每种语言的注释格式看来相差挺大的，需要小心严格遵循对应的语法 2025-09-22 目标：\n继续做基础美化 遇到的问题：\n链接 页面的卡片图片无法统一大小 备注：\n尝试解决后仍然失败，先用调整每张图片的方法暂时处理，等学完一些前端后再继续尝试统一处理 2025-09-23 目标：\n添加RSS，实现根据语言订阅不同版本 虚拟人物widget2D改为 moc3 版本 添加 网站底部动画 添加 博客发表热力图 遇到的问题：\n遇到的问题：\n虚拟人物无法加载 解决方法：\n通过浏览器 开发者工具 debug，获取error信息后结合AI排查出model存放地址的文件夹后少写\\ 思考/收获：\n在写文件地址时要小心核对 使用开发者工具debug很有用 2025-09-24 目标：\n引入新的虚拟人物模型，并将所有模型参数配置成自己喜欢的样式 遇到的问题：\n新的虚拟人物无法加载 通过CDN工具 jsDelivr 加载时发现它不加载新推送的文件 解决方法：\n通过浏览器 开发者工具 的报错信息发现，新模型加载失败是因为该模型过大导致，所以决定放弃使用这个新模型 询问AI得知，jsDelivr 出于稳定性的考虑，一旦tag（缓存）建立，就不会自动更新，即使删除并重建tag。如果版本号一致，那么它只会加载老版本的快照。最后采用了 精准 加载的方法处理，因为不想在仓库留下一堆无用的文件和tag 思考/收获：\n第一次意识到文件大小在网络传输时的重要性。就像我在玩Brotato这样Roguelike的后面几关时注意到大量游戏资源的管理是游戏开发的一个重点一样，每一个编程方向虽有其共性，但也有其特别需要关注的点，这些点需要在实战中慢慢体会 2025-09-29 目标：\n网页底部添加 运行时间、文章篇数 统计等信息 遇到的问题：\n中文显示乱码 解决方法：\n听从AI的建议用VS Code打开文件检查，发现在UTF-8下是乱码。修改后正常显示 思考/收获：\n发现用VS 2022打开并没有出现乱码，但是VS Code可以显示这一问题 只是在使用完VS Code，一点击 保存，它又会擅自更改格式，导致hugo无法编译 阶段小结一 目前进展： 完成个人技术博客的初步开发，包括自动部署和一定程度的美化 收获： 了解静态网站生成器的基本原理（配置 → 模板 → 渲染） 初步掌握GitHub Pages 部署流程 这一阶段没有学习过任何前端的内容，所以所有开发都是参考了网上大佬们的教程、以及在AI的帮助下完成的。在这一过程中学会了 如何向AI更精准地提问，让它来帮助我解决问题的能力 下一步计划： 系统学习前端，并尝试解决阶段一未解决的问题 阅读/ 理解 魔改部分 代码 按照 TODO list 持续更新本站 ","date":"2025-09-24T09:01:30+02:00","image":"https://nullshowjl.github.io/p/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/blog_hu_62d12f8d304d72ec.webp","permalink":"https://nullshowjl.github.io/p/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","title":"【开发日志】我的技术博客网站"},{"content":"概览 技术栈：C++ + EasyX\n项目目标：完成 EasyX 环境搭建，完成两个小demo（跟随鼠标的小球、井字棋），理解游戏循环的雏形\n课程来源：B站Up-VoidMatrix\n环境配置 EasyX：直接搜索“EasyX”，官网直接下载安装\n需要在头文件中包含\u0026lt;graphics.h\u0026gt;来使用EasyX中的库函数。\nDemo1 - 跟随鼠标的圆 设计思路 创建窗口并创建游戏主循环\n绘制圆并实现圆跟随鼠标移动\n用双缓冲对绘图进行优化\n开发流程 初始化窗口与主循环 我们使用initgraph()来初始化窗口，然后用一个死循环来避免窗口一闪而过。\n1 2 3 4 5 6 7 8 9 int main() { initgraph(1280, 720); while (true) { } return 0; } 这个死循环是所有游戏的通用框架。所有的输入处理和更新等都会在这个游戏主循环中进行：\n1 2 3 4 5 while (true) { // 玩家的输入 // 画面的更新 } 绘制圆 使用solidcircle() 来绘制圆。\n输入处理 使用peekmessage() 来处理输入。\n在EasyX中，鼠标的移动、点击，键盘的输入等，都被称之为“message”。每次我们有输入操作，EasyX都会将这些“消息”放入消息队列中，每次我们调用 peekmessage()，EasyX就会尝试从消息队列中拉取一个消息，成功返回 true，失败返回 false。所以我们另一个循环不断地从消息队列中拉取消息进行处理，直到消息队列中没有消息为止。\n查阅文档，peekmessge() 必须带有一个参数 msg，msg 是一个指向消息结构体 ExMessage 的指针，用来保存获取到的消息。而 ExMessage 中的一个成员 message 代表“消息标识”，它对应相应的鼠标和键盘等输入操作。于是整个输入处理可以写为：\n1 2 3 4 5 6 7 8 9 10 11 while (true) { ExMessage msg; // 实例化一个ExMessage结构体对象 while (peekmessage(\u0026amp;msg)) { if (msg == WM_MOUSEMOVE) { // 处理鼠标移动逻辑 } } } 清屏 如果不清屏的话，会连续绘制出的小球会展现鼠标移动的轨迹，所以在每次绘制小球前都需要先进行清屏。调用 cleardevice() 进行清屏。\n用双缓冲对绘图进行优化处理 使用BeginBatchDraw()、 FlushBatchDraw()和EndBatchDraw()双缓冲处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 BeginBatchDraw(); while (true) // 游戏主循环 { // 玩家输入 // 游戏更新 cleardevice(); // 清屏 // 绘制 FlushBatchDraw(); } EndBatchDraw(); 关键步骤 initgraph() 初始化图形窗口\npeekmessage() 获取鼠标移动消息\ncleardevice() 清屏\nsolidcircle(x, y, r) 绘制圆\nBeginBatchDraw()、 FlushBatchDraw()、EndBatchDraw()双缓冲优化绘图\n知识点 EasyX 的坐标系 EasyX 的坐标系在屏幕左上方，x 轴的正方向向右，y 轴的正方向向下。\n渲染缓冲区 可以把渲染缓冲区想象成一块巨大的画布，调用Draw逻辑的过程就是在“画布”上画画。先绘制的内容会被后绘制的内容覆盖，而调用cleardevice()就等于是用当前的填充颜色（默认黑色）将“画布”覆盖了一遍。\n调用BeginBatchDraw()就相当于EasyX为我们新建了一块画布，而这块画布就是新的渲染缓冲区。它和窗口的渲染缓冲区不一样的是，它是不可见的。随后执行的所有Draw逻辑，都会绘制在这块新的画布上。当调用FlushBatchDraw()和EndBatchDraw()时，EasyX会将这两块画布进行迅速交换，这一过程非常迅速以至于我们是看不见的。所以这样就解决因为绘制频繁而导致的画面闪烁问题。\n游戏主循环 在一个死循环中，不断执行：读取操作、处理数据、绘制画面的过程。\n1 2 3 4 5 6 while (true) { // 读取操作(); // 处理数据(); // 绘制画面(); } 在主循环开始之前，我们需要先对游戏数据进行初始化，所以这部分一般放置于BeginBatchDraw()之前。\n在主循环结束之后，需要相应地对游戏资源进行释放。\nDemo2 - 井字棋游戏 游戏介绍 玩家在3*3的棋盘上轮流下子，用O和X表示各自的棋子，如果一方任意三个相同的棋子连成一条直线或斜线时，这一方获胜；如果9个网格均被棋子填充但是却未出现获胜方时，则为平局。此demo只实现本地人人对战。\n设计思路 游戏主循环中三要素的设计 读取操作:\n对鼠标左键按下的消息进行处理。当鼠标左键点击空白的棋盘格子时，执行落子操作。\n数据处理:\n对游戏结束条件进行检测。游戏结束条件为三颗同类型的棋子连成一条直线/斜线，或者棋盘被填满。游戏结束时，使用弹窗。告诉玩家游戏结果，然后退出主循环。\n绘制画面:\n用line()将窗口绘制为3*3的网格棋盘。同样用line()在网格上绘制出交叉的对角线代表一方玩家执的X棋子。用circle()绘制出另一方玩家执的O棋子。\n在窗口左上角输出一行文字，告诉玩家即将落子的棋子类型。\n数据结构 棋盘和棋子:\n用二维数组char board_data[3][3]代表棋盘，用字符char 'X'和char 'O'代表棋子，而还未落子的格子用char '-'表示。\n游戏结束 分类讨论游戏结束的情况。\n情况一：某一方获胜。只需对X字符和O字符分别进行穷举判定。共8种。\n情况二：平局。棋盘中没有一个格子是字符-且没有玩家获胜的情况。\n开发流程 遵循的总体思路 先框架后细化。\n先把游戏主框架用代码表示 这样可以确保我们在写代码是不会被突然出现的细节打扰。使用一个bool running来判断游戏是否运行。使用CheckWin()和CheckDraw()来判断游戏结束是哪一种情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 bool running = true; ExMessage msg; BeginBatchDraw(); // 开启批量绘图 while (running) // 游戏主循环 { while (peekmessage(\u0026amp;msg)) // 读取操作 { } // 处理数据 if (CheckWin(\u0026#39;x\u0026#39;)) { // 跳出弹窗消息，结束游戏 MessageBox(GetHWnd(), _T(\u0026#34;x 玩家获胜\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } else if (CheckWin(\u0026#39;o\u0026#39;)) { // 类似上述处理 } else if (CheckDraw()) { // 类似上述处理 } cleardevice(); // 每次绘图前先清空画面 // 绘制所有的东西 DrawBoard(); // 绘制棋盘 DrawPiece(); // 绘制棋子 DrawPrompt(); // 绘制即将落子的棋子信息 FlushBatchDraw(); // 每次游戏循环后，都刷新批量绘图的缓冲区 } EndBatchDraw(); // 游戏结束，结束批量绘图 细化读取操作部分逻辑 鼠标的坐标在窗口其实是像素点的坐标，于是需要将鼠标的坐标转化为棋盘的网格。用图展示其对应的关系：\n对应的代码可以表示为：\n1 2 3 4 5 6 int x = msg.x; // 鼠标的像素坐标 int y = msg.y; int index_x = x / 200; // 鼠标的棋盘坐标 int index_y = y / 200; 然后，就可以进行落子的逻辑了。最后，记得在成功落子后切换为另一种类型的棋子。\n细化数据处理部分的逻辑 CheckWin()函数就按之前提到的穷举8种情况即可。CheckDraw()部分的代码，需要遍历棋盘的每一个格子，检查是否有\u0026rsquo;-\u0026rsquo;。需要注意的是，如果是一行一行检查的话，外层循环是列，而内层循环是行：\n1 2 3 4 5 6 7 8 9 10 for (int col = 0; col \u0026lt; 3; col++) { for (int row = 0; row \u0026lt; 3; row++) { if (board[row][col] == \u0026#39;-\u0026#39;) { // 相应逻辑 } } } 细化绘制部分的逻辑 棋盘的绘制：直接只用line()对应相应的像素坐标。\nX 棋子的绘制：同样使用line()绘制，只不过使用的是对角线的像素坐标。\nO 棋子的绘制：使用circle()绘制，圆心的x和y分别要在各自棋盘格子像素点的基础上多加100个像素单位。\n提示信息的绘制：为了在更通用的编码环境下使用，用了并不常见的类型和函数，但是和C中的printf()类似。\n1 2 static TCHAR str[64]; _stprintf_s(str, _T(\u0026#34;当前棋子类型：%c\u0026#34;), current_piece); 一些美化字体的函数：\n1 2 settextcolor(RGB(225, 175, 45)); // 把颜色变为橙色，在视觉上更醒目 outtextxy(0, 0, str); // 在指定位置输出str字符串 优化 最后一枚落子不绘制：\n如果胜负判断放在最后，那么由于MB_OK弹窗会等待玩家点击，点击后直接退出程序，会跳过最后一枚棋子的绘制。为了解决这个问题，这里简单粗暴的将绘制函数放在胜负判断的逻辑之前。\nCPU占用高：\n计算机在执行while循环时速度较快，我们编写的主循环在顷刻间已经执行完了成千上万次，占用了大量的CPU时间片。对于大部分物理刷新率仅有60Hz的显示设备来说，这是一种性能浪费。简单粗暴的解决方法是使用sleep(15)，让程序在每一次循环结束后强制等待15ms。但这不是推荐的做法。因为随游戏体量的增大，程序每次执行主循环所执行的计算任务可能是不同的，涉及到操作系统CPU计算资源的分配，会导致每次执行主循环所实际消耗的时间可能是不一样的。所以我们需要根据每一帧执行的实际耗时，动态计算在这之后要休眠多长时间。推荐的做法是我们自己设置帧率。用到的函数是GetTickCount()，它可以获取程序自运行开始以来到现在的毫秒数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 while (running) { DWORD start_time = GetTickCount(); // 获取此次循环初始时间 读取操作(); 处理数据(); 绘制画面(); DWORD end_time = GetTickCount(); // 获取此次循环结束时间 DWORD delta_time = end_time - start_time; // 计算间隔时间 // 依据间隔时间动态分配休眠时间 // 按每秒60帧刷新页面 if (delta_time \u0026lt; 1000 / 60) // 如果间隔时间\u0026lt;每秒60帧，要进行休眠；否则不需要。 { Sleep(1000 / 60 - delta_time); } } 释放资源(); } 完整源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 #include \u0026lt;graphics.h\u0026gt; char board_data[3][3] = { {\u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;}, {\u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;}, {\u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;} }; char current_piece = \u0026#39;O\u0026#39;; bool CheckWin(char c); bool CheckDraw(); void DrawBoard(); void DrawPiece(); void DrawPrompt(); int main() { //======= 初始化数据 ======= initgraph(600, 600); ExMessage msg; bool running = true; // 双缓冲，解决图形闪烁问题 BeginBatchDraw(); //======= 游戏主循环 ======= while (running) { DWORD start_time = GetTickCount(); while (peekmessage(\u0026amp;msg)) { //======= 读取操作 ======= // 检测鼠标左键按下后的消息 if (msg.message == WM_LBUTTONDOWN) { // 计算点击位置 int x = msg.x; int y = msg.y; int index_x = y / 200; int index_y = x / 200; //========= 处理数据 ========= // 落子 if (board_data[index_y][index_x] == \u0026#39;-\u0026#39;) { board_data[index_y][index_x] = current_piece;\t// 切换棋子类型 if (current_piece == \u0026#39;O\u0026#39;) { current_piece = \u0026#39;X\u0026#39;; } else if (current_piece == \u0026#39;X\u0026#39;) { current_piece = \u0026#39;O\u0026#39;; } } } }\tcleardevice(); //===== 绘制 ===== DrawBoard();\tDrawPiece(); DrawPrompt(); FlushBatchDraw(); // 判断胜负，出于解决最后一枚棋子绘制的问题而放在绘制逻辑之后 if (CheckWin(\u0026#39;X\u0026#39;)) { MessageBox(GetHWnd(), _T(\u0026#34;X 玩家获胜\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } else if (CheckWin(\u0026#39;O\u0026#39;)) { MessageBox(GetHWnd(), _T(\u0026#34;O 玩家获胜\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } else if (CheckDraw()) { MessageBox(GetHWnd(), _T(\u0026#34;平局\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } //======= 设置帧率（优化）======= DWORD end_time = GetTickCount(); DWORD delta_time = end_time - start_time; if (delta_time \u0026lt; 1000 / 60) { Sleep(1000 / 60 - delta_time); // 节约性能，补足帧率至60，不要运行得太快 } } EndBatchDraw(); return 0; } bool CheckWin(char c) { if (board_data[0][0] == c \u0026amp;\u0026amp; board_data[0][1] == c \u0026amp;\u0026amp; board_data[0][2] == c) return true; if (board_data[1][0] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[1][2] == c) return true; if (board_data[2][0] == c \u0026amp;\u0026amp; board_data[2][1] == c \u0026amp;\u0026amp; board_data[2][2] == c) return true; if (board_data[0][0] == c \u0026amp;\u0026amp; board_data[1][0] == c \u0026amp;\u0026amp; board_data[2][0] == c) return true; if (board_data[0][1] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[2][1] == c) return true; if (board_data[0][2] == c \u0026amp;\u0026amp; board_data[1][2] == c \u0026amp;\u0026amp; board_data[2][2] == c) return true; if (board_data[2][0] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[0][2] == c) return true; if (board_data[0][0] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[2][2] == c) return true; return false; } bool CheckDraw() { for (int col = 0; col \u0026lt; 3; col++) { for (int row = 0; row \u0026lt; 3; row++) { if (board_data[row][col] == \u0026#39;-\u0026#39;) { return false; } } } return true; } void DrawBoard() { line(0, 200, 600, 200); line(0, 400, 600, 400); line(200, 0, 200, 600); line(400, 0, 400, 600); } void DrawPiece() { for (int col = 0; col \u0026lt; 3; col++) { for (int row = 0; row \u0026lt; 3; row++) { switch (board_data[row][col]) { case \u0026#39;-\u0026#39;: break; case \u0026#39;O\u0026#39;: circle(200 * row + 100, 200 * col + 100, 100); break; case \u0026#39;X\u0026#39;: line(200 * row, 200 * col, 200 * (row + 1), 200 * (col + 1)); line(200 * (row + 1), 200 * col, 200 * row, 200 * (col + 1)); } } }\t} void DrawPrompt() { static TCHAR str[64]; _stprintf_s(str, _T(\u0026#34;当前棋子类型：%c\u0026#34;), current_piece); settextcolor(RGB(225, 175, 45)); outtextxy(0, 0, str); } 复盘和总结 这是我第一次如此透彻地理解游戏主循环、双缓冲机制、游戏中的坐标系以及帧率的设置。之前虽然也用C++和raylib做过一些小游戏，但是都是照猫画虎、囫囵吞枣、一知半解。这次的学习是跟着教程的思路和节奏做的，所以并未严格按照面向对象的思路去封装类，而是专注于用最简单、最快的实现方法，体会游戏的通用架构。按照top-down的思路，从框架到具体的一步步分解问题，逐个解决。计划跟完这位大佬的所有课程，在提升自己编程能力的同时，加深对游戏开发编程的理解，以及让自己的代码风格符合业界的惯例。\n","date":"2025-09-18T09:01:30+02:00","image":"https://nullshowjl.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/tictactoe_hu_918abf521d4890f0.webp","permalink":"https://nullshowjl.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","title":"【从零开始的C++游戏开发】基础"}]