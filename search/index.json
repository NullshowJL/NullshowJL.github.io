[{"content":"术语 英文表达 中文解释 使用场景 / 备注 curly braces 花括号 {} 常用于代码块、函数体 greater than or equal to (\u0026gt;=) 大于等于 条件判断 polymorphism 多态 面向对象编程核心概念 inheritance 继承 类之间的关系 encapsulation 封装 数据隐藏与接口暴露 constructor / destructor 构造函数 / 析构函数 C++类生命周期管理 reference / pointer 引用 / 指针 C++变量访问方式 overload / override 重载 / 重写 函数或运算符扩展 compile-time / runtime 编译时 / 运行时 性能与错误定位相关 stack / heap 栈 / 堆 内存管理 thread-safe 线程安全 并发编程 undefined behavior 未定义行为 编译器无法保证结果 template / generic 模板 / 泛型 C++/TypeScript等通用编程 STL (Standard Template Library) 标准模板库 C++常用数据结构与算法 lambda expression 匿名函数表达式 函数式编程风格 scope / lifetime 作用域 / 生命周期 变量可见性与存活时间 行业表达 英文表达 中文解释 使用场景 / 备注 MVP (Minimum Viable Product) 最小可行产品 产品开发初期 pivot 战略转向 产品或业务方向调整 iteration 迭代 敏捷开发周期 sprint 冲刺周期 敏捷开发术语 backlog 待办事项列表 项目管理 playtest 游戏测试 游戏开发流程 asset pipeline 资源处理流程 游戏美术与技术协作 hitbox / collision detection 碰撞盒 / 碰撞检测 游戏物理逻辑 frame rate / FPS 帧率 游戏性能指标 latency / lag 延迟 / 卡顿 网络性能问题 live ops 运营活动 游戏上线后的持续运营 monetization 变现策略 游戏商业模式 sandbox environment 沙盒环境 安全测试或实验环境 scalability 可扩展性 系统设计目标 CI/CD (Continuous Integration / Deployment) 持续集成 / 部署 DevOps 流程 表达习惯 英文表达 中文解释 使用场景 / 备注 Let\u0026rsquo;s refactor this module. 我们来重构这个模块。 团队协作时建议优化代码结构 This function is too tightly coupled. 这个函数耦合度太高。 表达设计问题 Can we abstract this logic? 我们能抽象这段逻辑吗？ 提高复用性 This breaks the single responsibility principle. 这违反了单一职责原则。 代码设计讨论 Let\u0026rsquo;s keep it DRY (Don\u0026rsquo;t Repeat Yourself). 避免重复代码。 编程原则 This is a bit verbose. 这段代码有点啰嗦。 表达代码简洁性问题 It\u0026rsquo;s more idiomatic to use\u0026hellip; 更符合语言习惯的是用\u0026hellip; 语言风格建议 Let\u0026rsquo;s decouple the UI from the logic. 把 UI 和逻辑分离。 前端架构优化 This is a good candidate for a helper function. 可以提取为辅助函数。 提高可读性 We should avoid side effects here. 应避免副作用。 函数式编程建议 面试沟通 英文表达 中文解释 使用场景 / 备注 I led the implementation of\u0026hellip; 我主导了\u0026hellip;的实现 项目介绍 We optimized the performance by\u0026hellip; 我们通过\u0026hellip;优化了性能 技术成果展示 I collaborated with cross-functional teams. 我与跨职能团队合作 展现沟通能力 One challenge we faced was\u0026hellip; 我们遇到的一个挑战是\u0026hellip; 问题分析 I proposed a solution that\u0026hellip; 我提出了一个解决方案\u0026hellip; 展现主动性 The project was deployed to production in\u0026hellip; 项目已上线于\u0026hellip; 项目成果说明 I ensured code quality through\u0026hellip; 我通过\u0026hellip;保障了代码质量 展现工程规范意识 I’m comfortable working in agile environments. 我适应敏捷开发环境 团队协作能力 I’m currently exploring C++ for backend performance. 我正在研究 C++ 提升后端性能 展现学习动力 I’d love to contribute to scalable systems. 我希望参与可扩展系统的开发 职业目标表达 ","date":"2025-09-28T10:28:14+02:00","image":"https://nullshowjl.github.io/p/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%B8%B8%E7%94%A8%E8%A1%A8%E8%BE%BE/professional-english_hu_d52f9ab8605f43dd.webp","permalink":"https://nullshowjl.github.io/p/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%B8%B8%E7%94%A8%E8%A1%A8%E8%BE%BE/","title":"【专业英语】常用表达"},{"content":"概览 项目目标：从零开始开发一个个人博客网站，用来记录和分享我在学习、开发中的笔记 、历程和感悟，也是 portfolio 的一部分 技术栈：GitHub Page + Hugo，在Stack theme基础上进行轻量定制修改 开始时间：2025-09-14 当前状态：进行中 学习资源：Hugo官方文档、stack主题文档、B站及网上各位大佬的教程 仓库链接：GitHub 时间线——阶段一 2025-09-14 目标： 创建网站并完成自动部署 添加基础版 看板娘 遇到的问题： 中英语切换时找不到网页 icon小图标在网站标签不显示 解决方法： 在VS Code中使用Github copilot，帮我写了转换语言的js文件 用在别人网页中成功显示的小图标进行测试，排除了图片本身的问题；后来因为处理别的模块，没有在意icon小图标，一段时间后自动显示出来了 思考/收获： 需要边开发边系统学习web programming，才能“知其然，知其所以然”，而不是百分之百依赖AI Github Pages的部署很快，但是在网页显示没有那么及时；如果检查了仓库已经推送上去了，如果此时效果还未显示，不要着急，等一等 2025-09-16 目标： 左边侧栏添加 更新日志 上传第一篇博客（中文版） 修改字体 使用自定义鼠标 遇到的问题： 自定义鼠标不显示 解决方法： 查看了教程博客的评论区，发现可能是图片的问题。使用了教程博主的图片素材测试，发现确实如此 思考/收获： 遇到问题可以看文章或者视频的评论区，常有启发和收获，因为我遇到过的问题也许别人早就遇到并解决了 2025-09-18 目标：做完一系列基础美化\n遇到的问题：\n不知道如何能使每个语言、代码都显示对应的字体 自动部署时遇到 语法报错 失败 解决方法：\n使用Copilot生成代码建议解决了字体问题 语法报错是和缩进有关的，用VS Code它会自动按照它认为对的格式，但其实是错的。换成 记事本 解决 思考/收获：\n前端的语言和缩进也是有关系的，以后需要用 记事本 或者其他编辑器操作，尽量不用VS Code避免类似情况发生 2025-09-19 目标：\n继续做基础美化 调整 背景颜色 图标和文本 添加 动态背景 添加 文章浏览量 统计 遇到的问题：\n调整背景颜色时先遇到了两个图标同时显示的问题，解决后发现 文本格式 没有和左侧菜单栏的其他项目文本对齐 备注：\n尝试解决了很久没有成功，先放一放，等学一段时间前端后再回过头来尝试解决\n2025-09-20 目标：\n继续做基础美化 添加 主页加载动画 添加 网站底部动画 添加 博客发表热力图 遇到的问题：\n网站底部出现不是博客内容的文字 想为 头像 下的小图标增加动画效果，但是没有实现效果 解决方法：\n利用AI排查出是custom.html的注释问题，我想当然地使用了C++的注释，但是被浏览器当做文本处理 备注：\n小图标 的动画效果在学完一些前端后再尝试解决（9-23已解决） 思考/收获：\n每种语言的注释格式看来相差挺大的，需要小心严格遵循对应的语法 2025-09-22 目标：\n继续做基础美化 遇到的问题：\n链接 页面的卡片图片无法统一大小 备注：\n尝试解决后仍然失败，先用调整每张图片的方法暂时处理，等学完一些前端后再继续尝试统一处理 2025-09-23 目标：\n添加RSS，实现根据语言订阅不同版本 虚拟人物widget2D改为 moc3 版本 添加 网站底部动画 添加 博客发表热力图 遇到的问题：\n遇到的问题：\n虚拟人物无法加载 解决方法：\n通过浏览器 开发者工具 debug，获取error信息后结合AI排查出model存放地址的文件夹后少写\\ 思考/收获：\n在写文件地址时要小心核对 使用开发者工具debug很有用 2025-09-24 目标：\n引入新的虚拟人物模型，并将所有模型参数配置成自己喜欢的样式 遇到的问题：\n新的虚拟人物无法加载 通过CDN工具 jsDelivr 加载时发现它不加载新推送的文件 解决方法：\n通过浏览器 开发者工具 的报错信息发现，新模型加载失败是因为该模型过大导致，所以决定放弃使用这个新模型 询问AI得知，jsDelivr 出于稳定性的考虑，一旦tag（缓存）建立，就不会自动更新，即使删除并重建tag。如果版本号一致，那么它只会加载老版本的快照。最后采用了 精准 加载的方法处理，因为不想在仓库留下一堆无用的文件和tag 思考/收获：\n第一次意识到文件大小在网络传输时的重要性。就像我在玩Brotato这样Roguelike的后面几关时注意到大量游戏资源的管理是游戏开发的一个重点一样，每一个编程方向虽有其共性，但也有其特别需要关注的点，这些点需要在实战中慢慢体会 阶段小结一 目前进展： 完成个人技术博客的初步开发，包括自动部署和一定程度的美化 收获： 了解静态网站生成器的基本原理（配置 → 模板 → 渲染） 初步掌握GitHub Pages 部署流程 这一阶段没有学习过任何前端的内容，所以所有开发都是参考了网上大佬们的教程、以及在AI的帮助下完成的。在这一过程中学会了 如何向AI更精准地提问，让它来帮助我解决问题的能力 下一步计划： 系统学习前端，并尝试解决阶段一未解决的问题 阅读/ 理解 魔改部分 代码 按照 TODO list 持续更新本站 ","date":"2025-09-24T09:01:30+02:00","image":"https://nullshowjl.github.io/p/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/blog_hu_ce474915f2b2dedb.jpg","permalink":"https://nullshowjl.github.io/p/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","title":"【开发日志】我的技术博客网站"},{"content":"概览 技术栈：C++ + EasyX\n项目目标：完成 EasyX 环境搭建，完成两个小demo（跟随鼠标的小球、井字棋），理解游戏循环的雏形\n课程来源：B站Up-VoidMatrix\n环境配置 EasyX：直接搜索“EasyX”，官网直接下载安装\n需要在头文件中包含\u0026lt;graphics.h\u0026gt;来使用EasyX中的库函数。\nDemo1 - 跟随鼠标的圆 设计思路 创建窗口并创建游戏主循环\n绘制圆并实现圆跟随鼠标移动\n用双缓冲对绘图进行优化\n开发流程 初始化窗口与主循环 我们使用initgraph()来初始化窗口，然后用一个死循环来避免窗口一闪而过。\n1 2 3 4 5 6 7 8 9 int main() { initgraph(1280, 720); while (true) { } return 0; } 这个死循环是所有游戏的通用框架。所有的输入处理和更新等都会在这个游戏主循环中进行：\n1 2 3 4 5 while (true) { // 玩家的输入 // 画面的更新 } 绘制圆 使用solidcircle() 来绘制圆。\n输入处理 使用peekmessage() 来处理输入。\n在EasyX中，鼠标的移动、点击，键盘的输入等，都被称之为“message”。每次我们有输入操作，EasyX都会将这些“消息”放入消息队列中，每次我们调用 peekmessage()，EasyX就会尝试从消息队列中拉取一个消息，成功返回 true，失败返回 false。所以我们另一个循环不断地从消息队列中拉取消息进行处理，直到消息队列中没有消息为止。\n查阅文档，peekmessge() 必须带有一个参数 msg，msg 是一个指向消息结构体 ExMessage 的指针，用来保存获取到的消息。而 ExMessage 中的一个成员 message 代表“消息标识”，它对应相应的鼠标和键盘等输入操作。于是整个输入处理可以写为：\n1 2 3 4 5 6 7 8 9 10 11 while (true) { ExMessage msg; // 实例化一个ExMessage结构体对象 while (peekmessage(\u0026amp;msg)) { if (msg == WM_MOUSEMOVE) { // 处理鼠标移动逻辑 } } } 清屏 如果不清屏的话，会连续绘制出的小球会展现鼠标移动的轨迹，所以在每次绘制小球前都需要先进行清屏。调用 cleardevice() 进行清屏。\n用双缓冲对绘图进行优化处理 使用BeginBatchDraw()、 FlushBatchDraw()和EndBatchDraw()双缓冲处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 BeginBatchDraw(); while (true) // 游戏主循环 { // 玩家输入 // 游戏更新 cleardevice(); // 清屏 // 绘制 FlushBatchDraw(); } EndBatchDraw(); 关键步骤 initgraph() 初始化图形窗口\npeekmessage() 获取鼠标移动消息\ncleardevice() 清屏\nsolidcircle(x, y, r) 绘制圆\nBeginBatchDraw()、 FlushBatchDraw()、EndBatchDraw()双缓冲优化绘图\n知识点 EasyX 的坐标系 EasyX 的坐标系在屏幕左上方，x 轴的正方向向右，y 轴的正方向向下。\n渲染缓冲区 可以把渲染缓冲区想象成一块巨大的画布，调用Draw逻辑的过程就是在“画布”上画画。先绘制的内容会被后绘制的内容覆盖，而调用cleardevice()就等于是用当前的填充颜色（默认黑色）将“画布”覆盖了一遍。\n调用BeginBatchDraw()就相当于EasyX为我们新建了一块画布，而这块画布就是新的渲染缓冲区。它和窗口的渲染缓冲区不一样的是，它是不可见的。随后执行的所有Draw逻辑，都会绘制在这块新的画布上。当调用FlushBatchDraw()和EndBatchDraw()时，EasyX会将这两块画布进行迅速交换，这一过程非常迅速以至于我们是看不见的。所以这样就解决因为绘制频繁而导致的画面闪烁问题。\n游戏主循环 在一个死循环中，不断执行：读取操作、处理数据、绘制画面的过程。\n1 2 3 4 5 6 while (true) { // 读取操作(); // 处理数据(); // 绘制画面(); } 在主循环开始之前，我们需要先对游戏数据进行初始化，所以这部分一般放置于BeginBatchDraw()之前。\n在主循环结束之后，需要相应地对游戏资源进行释放。\nDemo2 - 井字棋游戏 游戏介绍 玩家在3*3的棋盘上轮流下子，用O和X表示各自的棋子，如果一方任意三个相同的棋子连成一条直线或斜线时，这一方获胜；如果9个网格均被棋子填充但是却未出现获胜方时，则为平局。此demo只实现本地人人对战。\n设计思路 游戏主循环中三要素的设计 读取操作:\n对鼠标左键按下的消息进行处理。当鼠标左键点击空白的棋盘格子时，执行落子操作。\n数据处理:\n对游戏结束条件进行检测。游戏结束条件为三颗同类型的棋子连成一条直线/斜线，或者棋盘被填满。游戏结束时，使用弹窗。告诉玩家游戏结果，然后退出主循环。\n绘制画面:\n用line()将窗口绘制为3*3的网格棋盘。同样用line()在网格上绘制出交叉的对角线代表一方玩家执的X棋子。用circle()绘制出另一方玩家执的O棋子。\n在窗口左上角输出一行文字，告诉玩家即将落子的棋子类型。\n数据结构 棋盘和棋子:\n用二维数组char board_data[3][3]代表棋盘，用字符char 'X'和char 'O'代表棋子，而还未落子的格子用char '-'表示。\n游戏结束 分类讨论游戏结束的情况。\n情况一：某一方获胜。只需对X字符和O字符分别进行穷举判定。共8种。\n情况二：平局。棋盘中没有一个格子是字符-且没有玩家获胜的情况。\n开发流程 遵循的总体思路 先框架后细化。\n先把游戏主框架用代码表示 这样可以确保我们在写代码是不会被突然出现的细节打扰。使用一个bool running来判断游戏是否运行。使用CheckWin()和CheckDraw()来判断游戏结束是哪一种情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 bool running = true; ExMessage msg; BeginBatchDraw(); // 开启批量绘图 while (running) // 游戏主循环 { while (peekmessage(\u0026amp;msg)) // 读取操作 { } // 处理数据 if (CheckWin(\u0026#39;x\u0026#39;)) { // 跳出弹窗消息，结束游戏 MessageBox(GetHWnd(), _T(\u0026#34;x 玩家获胜\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } else if (CheckWin(\u0026#39;o\u0026#39;)) { // 类似上述处理 } else if (CheckDraw()) { // 类似上述处理 } cleardevice(); // 每次绘图前先清空画面 // 绘制所有的东西 DrawBoard(); // 绘制棋盘 DrawPiece(); // 绘制棋子 DrawPrompt(); // 绘制即将落子的棋子信息 FlushBatchDraw(); // 每次游戏循环后，都刷新批量绘图的缓冲区 } EndBatchDraw(); // 游戏结束，结束批量绘图 细化读取操作部分逻辑 鼠标的坐标在窗口其实是像素点的坐标，于是需要将鼠标的坐标转化为棋盘的网格。用图展示其对应的关系：\n对应的代码可以表示为：\n1 2 3 4 5 6 int x = msg.x; // 鼠标的像素坐标 int y = msg.y; int index_x = x / 200; // 鼠标的棋盘坐标 int index_y = y / 200; 然后，就可以进行落子的逻辑了。最后，记得在成功落子后切换为另一种类型的棋子。\n细化数据处理部分的逻辑 CheckWin()函数就按之前提到的穷举8种情况即可。CheckDraw()部分的代码，需要遍历棋盘的每一个格子，检查是否有\u0026rsquo;-\u0026rsquo;。需要注意的是，如果是一行一行检查的话，外层循环是列，而内层循环是行：\n1 2 3 4 5 6 7 8 9 10 for (int col = 0; col \u0026lt; 3; col++) { for (int row = 0; row \u0026lt; 3; row++) { if (board[row][col] == \u0026#39;-\u0026#39;) { // 相应逻辑 } } } 细化绘制部分的逻辑 棋盘的绘制：直接只用line()对应相应的像素坐标。\nX 棋子的绘制：同样使用line()绘制，只不过使用的是对角线的像素坐标。\nO 棋子的绘制：使用circle()绘制，圆心的x和y分别要在各自棋盘格子像素点的基础上多加100个像素单位。\n提示信息的绘制：为了在更通用的编码环境下使用，用了并不常见的类型和函数，但是和C中的printf()类似。\n1 2 static TCHAR str[64]; _stprintf_s(str, _T(\u0026#34;当前棋子类型：%c\u0026#34;), current_piece); 一些美化字体的函数：\n1 2 settextcolor(RGB(225, 175, 45)); // 把颜色变为橙色，在视觉上更醒目 outtextxy(0, 0, str); // 在指定位置输出str字符串 优化 最后一枚落子不绘制：\n如果胜负判断放在最后，那么由于MB_OK弹窗会等待玩家点击，点击后直接退出程序，会跳过最后一枚棋子的绘制。为了解决这个问题，这里简单粗暴的将绘制函数放在胜负判断的逻辑之前。\nCPU占用高：\n计算机在执行while循环时速度较快，我们编写的主循环在顷刻间已经执行完了成千上万次，占用了大量的CPU时间片。对于大部分物理刷新率仅有60Hz的显示设备来说，这是一种性能浪费。简单粗暴的解决方法是使用sleep(15)，让程序在每一次循环结束后强制等待15ms。但这不是推荐的做法。因为随游戏体量的增大，程序每次执行主循环所执行的计算任务可能是不同的，涉及到操作系统CPU计算资源的分配，会导致每次执行主循环所实际消耗的时间可能是不一样的。所以我们需要根据每一帧执行的实际耗时，动态计算在这之后要休眠多长时间。推荐的做法是我们自己设置帧率。用到的函数是GetTickCount()，它可以获取程序自运行开始以来到现在的毫秒数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 while (running) { DWORD start_time = GetTickCount(); // 获取此次循环初始时间 读取操作(); 处理数据(); 绘制画面(); DWORD end_time = GetTickCount(); // 获取此次循环结束时间 DWORD delta_time = end_time - start_time; // 计算间隔时间 // 依据间隔时间动态分配休眠时间 // 按每秒60帧刷新页面 if (delta_time \u0026lt; 1000 / 60) // 如果间隔时间\u0026lt;每秒60帧，要进行休眠；否则不需要。 { Sleep(1000 / 60 - delta_time); } } 释放资源(); } 完整源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 #include \u0026lt;graphics.h\u0026gt; char board_data[3][3] = { {\u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;}, {\u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;}, {\u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;-\u0026#39;} }; char current_piece = \u0026#39;O\u0026#39;; bool CheckWin(char c); bool CheckDraw(); void DrawBoard(); void DrawPiece(); void DrawPrompt(); int main() { //======= 初始化数据 ======= initgraph(600, 600); ExMessage msg; bool running = true; // 双缓冲，解决图形闪烁问题 BeginBatchDraw(); //======= 游戏主循环 ======= while (running) { DWORD start_time = GetTickCount(); while (peekmessage(\u0026amp;msg)) { //======= 读取操作 ======= // 检测鼠标左键按下后的消息 if (msg.message == WM_LBUTTONDOWN) { // 计算点击位置 int x = msg.x; int y = msg.y; int index_x = y / 200; int index_y = x / 200; //========= 处理数据 ========= // 落子 if (board_data[index_y][index_x] == \u0026#39;-\u0026#39;) { board_data[index_y][index_x] = current_piece;\t// 切换棋子类型 if (current_piece == \u0026#39;O\u0026#39;) { current_piece = \u0026#39;X\u0026#39;; } else if (current_piece == \u0026#39;X\u0026#39;) { current_piece = \u0026#39;O\u0026#39;; } } } }\tcleardevice(); //===== 绘制 ===== DrawBoard();\tDrawPiece(); DrawPrompt(); FlushBatchDraw(); // 判断胜负，出于解决最后一枚棋子绘制的问题而放在绘制逻辑之后 if (CheckWin(\u0026#39;X\u0026#39;)) { MessageBox(GetHWnd(), _T(\u0026#34;X 玩家获胜\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } else if (CheckWin(\u0026#39;O\u0026#39;)) { MessageBox(GetHWnd(), _T(\u0026#34;O 玩家获胜\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } else if (CheckDraw()) { MessageBox(GetHWnd(), _T(\u0026#34;平局\u0026#34;), _T(\u0026#34;游戏结束\u0026#34;), MB_OK); running = false; } //======= 设置帧率（优化）======= DWORD end_time = GetTickCount(); DWORD delta_time = end_time - start_time; if (delta_time \u0026lt; 1000 / 60) { Sleep(1000 / 60 - delta_time); // 节约性能，补足帧率至60，不要运行得太快 } } EndBatchDraw(); return 0; } bool CheckWin(char c) { if (board_data[0][0] == c \u0026amp;\u0026amp; board_data[0][1] == c \u0026amp;\u0026amp; board_data[0][2] == c) return true; if (board_data[1][0] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[1][2] == c) return true; if (board_data[2][0] == c \u0026amp;\u0026amp; board_data[2][1] == c \u0026amp;\u0026amp; board_data[2][2] == c) return true; if (board_data[0][0] == c \u0026amp;\u0026amp; board_data[1][0] == c \u0026amp;\u0026amp; board_data[2][0] == c) return true; if (board_data[0][1] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[2][1] == c) return true; if (board_data[0][2] == c \u0026amp;\u0026amp; board_data[1][2] == c \u0026amp;\u0026amp; board_data[2][2] == c) return true; if (board_data[2][0] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[0][2] == c) return true; if (board_data[0][0] == c \u0026amp;\u0026amp; board_data[1][1] == c \u0026amp;\u0026amp; board_data[2][2] == c) return true; return false; } bool CheckDraw() { for (int col = 0; col \u0026lt; 3; col++) { for (int row = 0; row \u0026lt; 3; row++) { if (board_data[row][col] == \u0026#39;-\u0026#39;) { return false; } } } return true; } void DrawBoard() { line(0, 200, 600, 200); line(0, 400, 600, 400); line(200, 0, 200, 600); line(400, 0, 400, 600); } void DrawPiece() { for (int col = 0; col \u0026lt; 3; col++) { for (int row = 0; row \u0026lt; 3; row++) { switch (board_data[row][col]) { case \u0026#39;-\u0026#39;: break; case \u0026#39;O\u0026#39;: circle(200 * row + 100, 200 * col + 100, 100); break; case \u0026#39;X\u0026#39;: line(200 * row, 200 * col, 200 * (row + 1), 200 * (col + 1)); line(200 * (row + 1), 200 * col, 200 * row, 200 * (col + 1)); } } }\t} void DrawPrompt() { static TCHAR str[64]; _stprintf_s(str, _T(\u0026#34;当前棋子类型：%c\u0026#34;), current_piece); settextcolor(RGB(225, 175, 45)); outtextxy(0, 0, str); } 复盘和总结 这是我第一次如此透彻地理解游戏主循环、双缓冲机制、游戏中的坐标系以及帧率的设置。之前虽然也用C++和raylib做过一些小游戏，但是都是照猫画虎、囫囵吞枣、一知半解。这次的学习是跟着教程的思路和节奏做的，所以并未严格按照面向对象的思路去封装类，而是专注于用最简单、最快的实现方法，体会游戏的通用架构。按照top-down的思路，从框架到具体的一步步分解问题，逐个解决。计划跟完这位大佬的所有课程，在提升自己编程能力的同时，加深对游戏开发编程的理解，以及让自己的代码风格符合业界的惯例。\n","date":"2025-09-18T09:01:30+02:00","image":"https://nullshowjl.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%A1%80/tictactoe_hu_10af30a82500198a.webp","permalink":"https://nullshowjl.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%A1%80/","title":"【从零开始的C++游戏开发】- 基础"}]